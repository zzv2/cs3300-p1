<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" type="text/css" href="css/style.css">
  <script src="js/jquery-1.12.1.min.js"></script>
  <script src="d3/d3.min.js" charset="utf-8"></script>
  <title>Project 1</title>
</head>
<body>
  <section id="fest" class="displays">
     <div class="container">
        <div class="row">
           <div class="col5">
             <div class="display">
                <p>Ever look up in the sky and wonder what the heck is going on out there?</p>
                <p>Is it a bird? A lost balloon? or dare I say it--an alien?</p>
                <p>Nope! It's</p>
                <br>
                <h2>
                   ASTEROIDS!!!
                </h2>
                <br>
                <p>...and NASA's got you covered.</p>
                <br>
                <br>
                <p>All of the data we used was pulled from NASA's NeoWs online api available <a href="https://api.nasa.gov/api.html#NeoWS">here</a></p>
                <p class="graph-desc">The following graph uses NASA's data to depict near earth objects. Near eath objects are asteroids that get pushed into planet Earth's outer realm via the gravitational forces of other extraterrestrial objects.</p>
                <p class="graph-desc">The graph below is polar, with polar coordinates and each dot represents a unique asteroid, each with a unique name. The dot’s location on the angular axis represents the time after January 1st 2016 and extends counterclockwise until December 31st 2016. The dot’s location on the radial axis represents the asteroid’s nearest distance to Earth in passing. The size of each circle directly corresponds to the asteroids diameter. Each dot’s color is indicative of the asteroid’s relative velocity, with light yellow being slowest and dark red being fastest. The green dot in the very center of the graph represents Earth. However, please note that due to the minuscule sizes of the near earth objects relative to Earth, Earth is not drawn to scale. </p>
                <div id="graph1output"></div>
                <p class="graph-desc">Did you notice anything strange about the graph above? It seems there are a lot of objects really close to Earth.<br>But DON’T WORRY—we are not being attacked by asteroids. And in fact, none of these asteroids are deemed hazardous.</p>
                <p class="graph-desc">The second graph displayed below should put you more at ease. This particular graph is identical to the latter, except this time, the radial axis (distance from Earth) is scaled logarithmically. For reference, the moon’s orbit is displayed with a white ring and the average satellite’s orbit is displayed with a purple ring. Now notice how a majority of the near earth objects are at least one million miles away—which is approximately 4 times further than the distance from Earth to the moon! </p>
                <div id="graph2output"></div>
                 <p class="graph-desc">But which points are the important ones? To help better make sense of all the clutter that is outer space, the following graph highlights some asteroid with the most extreme properties (distance, diameter, velocity). </p>
                <div id="graph3output"></div>
                <p>FOR JOHN</p>
                <div id="graph4output"></div>
              </div>
           </div>
        </div>
     </div>
  </section>
<script>
//Initialize global variables
var data = [],  //will store all of the data returned
    tenMilData = [], //stores data representing asteroids with a distance of 10 million or less
    fiveMilData = [], //stores data representing asteroids with a distance of 5 million or less
    oneMilData = [] //stores data representing asteroids with a distance of 1 million or less
    halfMilData = []; //stores data representing asteroids with a distance less than 0.5 million
//***Describe***
  function pad(n, width, z) {
    z = z || '0';
    n = n + '';
    return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
  }
//***Describe***
  function dayofyear(d) {   // d is a Date object
    var yn = d.getFullYear();
    var mn = d.getMonth();
    var dn = d.getDate();
    var d1 = new Date(2016,0,1,12,0,0); // noon on Jan. 1
    var d2 = new Date(yn,mn,dn,12,0,0); // noon on input date
    var ddiff = Math.round((d2-d1)/864e5);
    return ddiff+2;
  }
  // dictionary 'counts' has keys 0-53
  // values of 'counts' are dictionaries which hold counts of distance
  // used for frequency data in graph 2
  var counts = {};
  for (var i=1; i<=53; i++) {
    counts[i] = {};
    for (var j=0; j<=50000000; j+=1000000) {
      counts[i][j] = 0;
    }
  }
  //***DESCRIBE***
  // code for following function taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor
  (function() {
  /**
   * Decimal adjustment of a number.
   *
   * @param {String}  type  The type of adjustment.
   * @param {Number}  value The number.
   * @param {Integer} exp   The exponent (the 10 logarithm of the adjustment base).
   * @returns {Number} The adjusted value.
   */
  function decimalAdjust(type, value, exp) {
    // If the exp is undefined or zero...
    if (typeof exp === 'undefined' || +exp === 0) {
      return Math[type](value);
    }
    value = +value;
    exp = +exp;
    // If the value is not a number or the exp is not an integer...
    if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
      return NaN;
    }
    // Shift
    value = value.toString().split('e');
    value = Math[type](+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
    // Shift back
    value = value.toString().split('e');
      return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
    }
    // Decimal round
    if (!Math.round10) {
      Math.round10 = function(value, exp) {
        return decimalAdjust('round', value, exp);
      };
    }
    // Decimal floor
    if (!Math.floor10) {
      Math.floor10 = function(value, exp) {
        return decimalAdjust('floor', value, exp);
      };
    }
    // Decimal ceil
    if (!Math.ceil10) {
      Math.ceil10 = function(value, exp) {
        return decimalAdjust('ceil', value, exp);
      };
    }
  })();

  // code for following function taken from http://bl.ocks.org/eesur/4e0a69d57d3bfc8a82c2
  d3.selection.prototype.moveToFront = function() {
    return this.each(function(){
      this.parentNode.appendChild(this);
    });
  };

 //***DESCRIBE***//
  function processJSON(json) {
    $.each(json["near_earth_objects"], function(k1, v1) {
      $.each(json["near_earth_objects"][k1], function(k2, v2) {
        var obj = {};
        obj.name = v2["name"];
        var minDiameter = v2["estimated_diameter"]["feet"]["estimated_diameter_min"],
            maxDiameter = v2["estimated_diameter"]["feet"]["estimated_diameter_max"];
        obj.diameter = minDiameter+maxDiameter/2; //get average diameter estimation
        obj.date = dayofyear(new Date(k1));
        var week = Math.ceil((obj.date / 371)*53);
        var roundedDistance = Math.floor10(v2["close_approach_data"][0]["miss_distance"]["miles"], 6);
        counts[week][roundedDistance] += 1;
        obj.miss_distance = v2["close_approach_data"][0]["miss_distance"]["miles"];
        obj.velocity = v2["close_approach_data"][0]["relative_velocity"]["miles_per_hour"];
        obj.highlight = true;
        data.push(obj);
      });
    });
  }
  //***DESCRIBE***//
  console.log("Loading Data...")
  var numWeeks = 53;
  for(var i=1; i<=numWeeks; i++) {
    $.ajax({
      url: pad(i,2)+".json",
      async: false,
      dataType: 'json',
      success: function (json) {
        processJSON(json);
      }
    });
  }
  console.log("Done.")
  console.log(data);
for (var i=0; i<data.length; i++) {
  if (data[i].miss_distance <= 10000000) {
    tenMilData.push(data[i]);
  }
}
for (var i=0; i<data.length; i++) {
  if (data[i].miss_distance <= 5000000) {
    fiveMilData.push(data[i]);
  }
}
for (var i=0; i<data.length; i++) {
  if (data[i].miss_distance <= 1000000) {
    oneMilData.push(data[i]);
  }
}
for (var i=0; i<data.length; i++) {
  if (data[i].miss_distance <= 500000) {
    halfMilData.push(data[i]);
  }
}
</script>

<script>
  var width = 800,
    height = 1000,
    radius = Math.min(width, height) / 2 - 80;
  var r = d3.scale.linear()
    .domain([0, 1])
    .range([0, radius]);
  var line = d3.svg.line.radial()
    .radius(function(d) {
      return r(d[1]);
    })
    .angle(function(d) {
      return -d[0] + Math.PI / 2;
    });
function makeGraph(div, data, maxDist, type) {
  var svg = d3.select(div).append("svg")
    .attr("width", width+200)
    .attr("height", height)
    .append("g")
    .attr("transform", "translate(" + (width) / 2 + "," + width / 2 + ")");
    svg.append("circle")
      .attr("r", radius)
      .attr("id", "#background-circle")
      .attr("fill", "#000000")

  var gr;

  if (type == "linear") {
    gr = svg.append("g")
      .attr("class", "r axis")
      .selectAll("g")
      .data(r.ticks(5).slice(1))
      .enter().append("g");
  }
  else {
    gr = svg.append("g")
      .attr("class", "r axis")
      .selectAll("g")
      .data(r.ticks(5).slice(1))
      .enter().append("g");
  }
  gr.append("circle")
    .attr("r", r)
  var ga = svg.append("g")
    .attr("class", "a axis")
    .selectAll("g")
    .data(d3.range(0, 360, 15))
    .enter().append("g")
    .attr("transform", function(d) {
      return "rotate(" + -d + ")";
    });
  ga.append("line")
    .attr("x2", function(d) { if(d%30==0){ return radius - 10} });
  ga.append("text")
    .attr("x", radius)
    .attr("dy", ".35em")
    .style("text-anchor", "middle")
    .attr("transform", "rotate(90 " + (radius) + ",0)")
    .text(function(d) {
      var months = {15:"January", 45:"February", 75:"March", 105:"April", 135:"May", 165:"June",
                    195:"July", 225:"August", 255:"September", 285:"October", 315:"November", 345:"Decemeber"};
      if (months[d]!=undefined){
        return months[d].toUpperCase()
      }
    });
  var circleData = [];
  var distanceData = [];
  var diameterData = [];
  var dateData = [];
  var velocityData = [];
  for (var i=0; i<data.length; i++) {
    var obj = data[i];
    velocityData.push(obj.velocity);
    dateData.push(obj.date);
    diameterData.push(obj.diameter);
    distanceData.push(obj.miss_distance);
    circleData.push(obj);
  }

  var line = d3.svg.line.radial()
    .radius(function(d) {
      return r(d[1]);
    })
    .angle(function(d) {
      return -d[0] + Math.PI / 2;
    });
  function getMinMax(data) {
    return [Math.min.apply(Math, data), Math.max.apply(Math, data)];
  }
  Array.prototype.max = function(){
    return Math.max.apply(Math, this);
  }
  Array.prototype.min = function(){
    return Math.min.apply(Math, this);
  }
  Array.prototype.mean = function(){
    var total = 0;
    var count = 0;
    for (i=0; i< this.length; i++) {
      if (this[i] != "max" && this[i] != "min" && this[i] != "min_max") {
        total += Number(this[i]);
        count += 1;
      }
    }
    console.log(total, count);
    return total / count;
  }
  Array.prototype.min_max = function(){
    return [Math.min.apply(Math, this), Math.max.apply(Math, this)];
  }

  var minDistance = distanceData.min();
  var maxDistance = distanceData.max();
  var avgDistance = distanceData.mean();

  var minDiam = diameterData.min();
  var maxDiam = diameterData.max();
  var avgDiam = diameterData.mean();

  var minVelocity = velocityData.min();
  var maxVelocity = velocityData.max();
  var avgVelocity = velocityData.mean();

  var minDistPoint, maxDistPoint, avgDistPoint;
  var minDiamPoint, maxDiamPoint, avgDiamPoint;
  var minVeloPoint, maxVeloPoint, avgVeloPoint;

  for (var i=0; i<data.length; i++) {
    var object = data[i];

    if (object.miss_distance == minDistance) {
      minDistPoint = object;
    } else if (object.miss_distance == maxDistance) {
      maxDistPoint = object;
    }
    if (object.diameter == minDiam) {
      minDiamPoint = object;
    } else if (object.diameter == maxDiam) {
      maxDiamPoint = object;
    }
    if (object.velocity == minVelocity) {
      minVeloPoint = object;
    } else if (object.velocity == maxVelocity) {
      maxVeloPoint = object;
    }
  }
  minDistPoint.highlight = false;
  maxDistPoint.highlight = false;
  minDiamPoint.highlight = false;
  maxDiamPoint.highlight = false;
  minVeloPoint.highlight = false;
  maxVeloPoint.highlight = false;

  var diameterScale = d3.scale.linear()
    .domain(diameterData.min_max())
    .range([2, 10]);
  var circleInner = 10;
  var circleOuter = radius;
  console.log(distanceData.max());
  var distScale;
  if (type == "linear") {
    distScale = d3.scale.linear()
      .domain([0,maxDist])
      .range([0, circleOuter + 65]);
  }
  else {
    distScale = d3.scale.log()
      .domain([1,maxDist])
      .range([0, circleOuter]);
  }

  var dateScale = d3.scale.linear()
    .domain([0,365])
    .range([0, 2*3.1415]);
  var startColor = "#FFF5AB", stopColor = "#E80010";
  var colorScale = d3.scale.linear()
    .domain([0, 100000])
    .range([startColor, stopColor]);
  function getPolarCoords(r, theta) {
    return [r*Math.cos(theta),-r*Math.sin(theta)]
  }
  svg.selectAll("point")
    .data(circleData)
    .enter()
    .append("circle")
    .attr("class", "point")
    .attr("transform", function(d) {
      // console.log(d.point);
      var r = distScale(d.miss_distance), theta = dateScale(d.date);
      var coords = getPolarCoords(r, theta);
      // console.log(coords);
      return "translate(" + coords + ")"
    })
    .attr( 'r', function(d) { return diameterScale(d.diameter) })
    .attr("fill", function(d) { return (type != "highlight" || (type == "highlight" && d.highlight == false)) ? colorScale(d.velocity) : "rgba(130,130,130,.5)"})
    .attr("id", function(d) { return (type != "highlight" || (type == "highlight" && d.highlight == false)) ? "highlighted" : "none"});
    d3.selectAll("#highlighted").moveToFront();
    var distAxis = d3.svg.axis()
      .scale(distScale)
      .orient('bottom')
      .ticks(5, ",.1s")
      .tickSize(6, 0);
    var distAxis = svg.append('g')
      .attr('class', 'distanceLabel')
      .attr("transform", "translate(0,0)")
      .call(distAxis);
    distAxis.append("text")
      .attr("class", "distanceLabel")
      .attr("x", circleOuter + 170)
      .attr("y", 5)
      .attr("font-size", 14)
      .attr("fill", "black")
      .style("text-anchor", "middle")
      .text("Distance from Earth (mi)");
    // color legend
    var gradient = svg.append("defs")
      .append("linearGradient")
        .attr("id", "gradient")
        .attr("x1", "0%")
        .attr("y1", "0%")
        .attr("x2", "100%")
        .attr("y2", "0%")
        .attr("spreadMethod", "pad");
    gradient.append("stop")
      .attr("offset", "0%")
      .attr("stop-color", startColor)
      .attr("stop-opacity", 1);
    gradient.append("stop")
      .attr("offset", "100%")
      .attr("stop-color", stopColor)
      .attr("stop-opacity", 1);
    var colorAxisScale = d3.scale.linear()
      .domain([0, 100000])
      .range([0, width / 2]);
    var colorAxis = d3.svg.axis()
      .scale(colorAxisScale)
      .orient('bottom')
      .ticks(5, ",.1s")
      .tickSize(10, 1);
    var colorLegend = svg.append('g')
      .attr('class', 'colorAxis')
      .attr("transform", "translate(" + -width / 4 + "," + width*0.5  + ")")
      .call(colorAxis)
    colorLegend.append("rect")
      .attr("class", "legend")
      .attr("width", width/2)
      .attr("height", height/32)
      .attr("transform", "translate(0,-40)")
      .style("fill", "url(#gradient)");
    colorLegend.append("text")
          .attr("class", "label")
          .attr("x", width/4)
          .attr("y", 50)
          .attr("font-size", 14)
          .attr("fill", "none")
          .style("text-anchor", "middle")
          .text("Relative Velocity (mph)");
          svg.append("circle")
          .attr("r", "5")
          .attr("cx", "0")
          .attr("cy", "0")
          .attr("fill", "#A2FF5E")
          svg.append("circle")
          .attr("r", distScale(238900))
          .attr("cx", "0")
          .attr("cy", "0")
          .attr("fill", "none")
          .attr("stroke", "#FFFFFF");
    if (type == "highlight") {

      function drawTextOnPoint(object) {
        console.log(minDistPoint);
        var r = distScale(object.miss_distance), theta = dateScale(object.date);
        var coords = getPolarCoords(r, theta);

        svg.append("line")
        .attr("x1", 0)
        .attr("x2", coords[0])
        .attr("y1", 0)
        .attr("y2", coords[1])
        .attr("transform", "translate(" + coords + ")")
        .attr("stroke", "green")
        .attr("class", "highlight-line");
      }
      drawTextOnPoint(minDistPoint);
      drawTextOnPoint(maxDistPoint);
      drawTextOnPoint(minDiamPoint);
      drawTextOnPoint(maxDiamPoint);
      drawTextOnPoint(minVeloPoint);
      drawTextOnPoint(maxVeloPoint);
    }
}
d3.selectAll(".highlight-line").moveToFront();
makeGraph("#graph1output", data, 60000000, "linear");
makeGraph("#graph2output", data, 10000000000, "log");
makeGraph("#graph3output", data, 10000000000, "highlight");
</script>

<script>
  var width = 800, height = 1000;
  var padding_left = 180;
  var padding_top = 50;
  var padding_bottom = 300;

  var svg = d3.select("#graph4output").append("svg")
    .attr("width", width+200)
    .attr("height", height)
    .append("g")
    .attr("fill", "white");

  var xScale = d3.scale.linear().domain([0, 54]).range([padding_left, width]);
  var yScale = d3.scale.linear().domain([0, 51000000]).range([height - padding_bottom, padding_top]);

  var xAxis = d3.svg.axis().scale(xScale).orient("bottom").ticks(26);
  var yAxis = d3.svg.axis().scale(yScale).orient("left").ticks(5);

  svg.append("g").attr("transform", "translate(0," + (height - padding_bottom) + ")").attr("class", "axis").attr("fill", "None")
  .call(xAxis);
  svg.append("g").attr("transform", "translate(" + padding_left + ",0)").attr("class", "axis").attr("fill", "None")
  .call(yAxis);

  var startColor = "#FFF5AB", stopColor = "#E80010";
  var colorScale = d3.scale.linear()
    .domain([0, 8])
    .range([startColor, stopColor]);

  // color legend
  var gradient = svg.append("defs")
    .append("linearGradient")
      .attr("id", "gradient")
      .attr("x1", "0%")
      .attr("y1", "0%")
      .attr("x2", "100%")
      .attr("y2", "0%")
      .attr("spreadMethod", "pad");

  gradient.append("stop")
    .attr("offset", "0%")
    .attr("stop-color", startColor)
    .attr("stop-opacity", 1);

  gradient.append("stop")
    .attr("offset", "100%")
    .attr("stop-color", stopColor)
    .attr("stop-opacity", 1);


  var colorAxisScale = d3.scale.linear()
    .domain([0, 8])
    .range([0, width / 2]);

  var colorAxis = d3.svg.axis()
    .scale(colorAxisScale)
    .orient('bottom')
    .ticks(5, ",.1s")
    .tickSize(10, 1);

  var colorLegend = svg.append('g')
    .attr('class', 'colorAxis')
    .attr("transform", "translate(" + 290 + "," + 825 + ")")
    .call(colorAxis)

  colorLegend.append("rect")
    .attr("class", "legend")
    .attr("width", width/2)
    .attr("height", height/32)
    .attr("transform", "translate(0,-40)")
    .style("fill", "url(#gradient)");

  colorLegend.append("text")
        .attr("class", "label")
        .attr("x", width/4)
        .attr("y", 50)
        .attr("font-size", 14)
        .attr("fill", "none")
        .style("text-anchor", "middle")
        .text("Frequency");

  for (var key in counts) {
    for (var distance in counts[key]) {
      if (distance != "max" && distance != "min" && distance != "min_max") {
        svg.append("rect")
        .attr("x", xScale(key) - 5)
        .attr("y", yScale(distance) - 5)
        .attr("width", 10)
        .attr("height", 10)
        .attr("fill", colorScale(counts[key][distance]))
        .attr("transform", "translate(" + 0 + "," + -1 + ")");
      }
    }
  }
  svg.append("text")
  .attr("x", 490)
  .attr("y", 760)
  .attr("text-anchor", "middle")
  .attr("class", "distanceLabel")
  .attr("font-size", 20)
  .text("Week");

  svg.append("text")
  .attr("x", 0)
  .attr("y", 325)
  .attr("alignment-baseline", "central")
  .attr("class", "distanceLabel")
  .attr("font-size", 20)
  .text("Distance");

  svg.append("text")
  .attr("x", 10)
  .attr("y", 350)
  .attr("alignment-baseline", "central")
  .attr("class", "distanceLabel")
  .attr("font-size", 20)
  .text("(miles)");

  var startDate = dayofyear(new Date('2016-03-02'));
  startDate = startDate / 7;

  svg.append("line")
  .attr("x1", xScale(startDate))
  .attr("x2", xScale(startDate))
  .attr("y1", yScale(0) + 4)
  .attr("y2", yScale(50000000) - 6)
  .attr("stroke", "#4B27FF")
  .attr("stroke-width", 2);
</script>

</body>
</html>
